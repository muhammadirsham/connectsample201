__copyright__ = "Copyright (c) 2020-2022, NVIDIA CORPORATION. All rights reserved."
__license__ = """
NVIDIA CORPORATION and its licensors retain all intellectual property
and proprietary rights in and to this software, related documentation
and any modifications thereto. Any use, reproduction, disclosure or
distribution of this software and related documentation without an express
license agreement from NVIDIA CORPORATION is strictly prohibited.
"""

import re

from omni.bind import model
from omni.bind.diagnostics import DiagnosticReporter
from omni.bind.generate import CodeGenerator
from omni.bind.recase import to_snake_case


class CppGenerator(CodeGenerator):
    """Code generator for generating an interface's C++ API wrapper."""

    def __init__(
        self,
        matches,
        hierarchy,
        out_filename,
        *,
        skip_write_if_same,
        fail_on_write,
        reporter: DiagnosticReporter,
        format_module=None,
        repo_root=None,
    ):
        super().__init__(
            matches,
            hierarchy,
            out_filename,
            skip_write_if_same=skip_write_if_same,
            fail_on_write=fail_on_write,
            reporter=reporter,
            format_module=format_module,
            repo_root=repo_root,
        )

        self._write(
            f"""\
// Copyright (c) {self._copyright_year}, NVIDIA CORPORATION. All rights reserved.
//
// NVIDIA CORPORATION and its licensors retain all intellectual property
// and proprietary rights in and to this software, related documentation
// and any modifications thereto. Any use, reproduction, disclosure or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA CORPORATION is strictly prohibited.
//
// --------- Warning: This is a build system generated file. ----------
//

//! @file
//!
//! @brief This file was generated by <i>omni.bind</i>.

#include <omni/core/OmniAttr.h>
#include <omni/core/Interface.h>
#include <omni/core/ResultError.h>

#include <functional>
#include <utility>
#include <type_traits>

#ifndef OMNI_BIND_INCLUDE_INTERFACE_IMPL
"""
        )

        decl = ""
        impl = ""
        for interface in matches.interfaces:
            output = self._convert_interface(interface)
            decl += output[0]
            impl += output[1]

        self._write(
            f"""
        {decl}
        #endif

        #ifndef OMNI_BIND_INCLUDE_INTERFACE_DECL
        {impl}
        #endif

        #undef OMNI_BIND_INCLUDE_INTERFACE_DECL
        #undef OMNI_BIND_INCLUDE_INTERFACE_IMPL
        """
        )

        for struct in matches.structs:
            if not struct.attributes.no_api:
                self._write(self._convert_struct(struct))

        self._commit()

    def _convert_interface(self, interface):
        impl = ""
        decl = f"""
            {interface.comment}
            template <>
            class omni::core::Generated<{interface.abi_name}> : public {interface.abi_name}
            {{
            public:
            OMNI_PLUGIN_INTERFACE("{interface.name}")
            """

        # on the first pass create trivial wrappers around abi functions
        for method in interface.methods:
            if method.attributes.no_api:
                continue

            parameters = ""
            pre_abi_call = ""
            abi_call_parameters = ""
            post_abi_call = ""
            separator = ""
            throws = False
            return_type = ""
            return_stmt = ""
            for i in range(len(method.parameters)):
                param = method.parameters[i]
                if param.is_interface_pointer and param.is_const_pointer:
                    self.reporter.error(param.cursor, "interface pointers should not be const")
                (
                    parameters_text,
                    pre_call_text,
                    call_text,
                    post_call_text,
                    method_throws,
                    return_type_text,
                    return_text,
                ) = self._convert_parameter(method, param)
                if len(parameters_text) > 0:
                    parameters += f"{separator}{parameters_text}"
                pre_abi_call += pre_call_text
                if len(call_text) > 0:
                    abi_call_parameters += f"{separator}{call_text}"
                post_abi_call += post_call_text
                separator = ", "
                throws = throws or method_throws
                if (len(return_type_text) > 0) and (len(return_type) > 0):
                    self._reporter.error(param.cursor, "multiple parameters are trying to set the return type")
                else:
                    return_type = return_type_text

                if (len(return_text) > 0) and (len(return_stmt) > 0):
                    self._reporter.error(param.cursor, "multiple parameters are trying to set the return type")
                else:
                    return_stmt = return_text

            if len(return_type) == 0:
                return_type = self._convert_return(method)

            if method.throws_result:
                abi_call = f"OMNI_THROW_IF_FAILED({method.abi_name}({abi_call_parameters}))"
                throws = True
            else:
                abi_call = f"{method.abi_name}({abi_call_parameters})"

            if (len(pre_abi_call) == 0) and (len(post_abi_call) == 0):
                if method.returns_interface_pointer and not method.returns_interface_pointer_without_acquire:
                    abi_call = f"return omni::core::steal({abi_call});"
                elif method.returns_kit_interface_pointer:
                    abi_call = f"return carb::stealObject({abi_call});"
                elif method.returns_void or method.throws_result:
                    abi_call = f"{abi_call};"
                elif method.can_return_reference:
                    abi_call = f"return *({abi_call});"
                else:
                    abi_call = f"return {abi_call};"
            else:
                if len(return_stmt) != 0:
                    abi_call = f"{abi_call};"
                    post_abi_call += f"{post_abi_call}{return_stmt}"
                elif method.returns_interface_pointer and not method.returns_interface_pointer_without_acquire:
                    abi_call = f"auto return_ = omni::core::steal({abi_call});"
                    post_abi_call += f"{post_abi_call}return return_;"
                elif method.returns_kit_interface_pointer:
                    abi_call = f"auto return_ = carb::stealObject({abi_call});"
                    post_abi_call += f"{post_abi_call}return return_;"
                elif method.returns_void or method.throws_result:
                    abi_call = f"{abi_call};"
                elif method.can_return_reference:
                    abi_call = f"auto& return_ = *({abi_call});"
                    post_abi_call += f"{post_abi_call}return return_;"
                else:
                    abi_call = f"auto return_ = {abi_call};"
                    post_abi_call += f"{post_abi_call}return return_;"

            if throws:
                noexcept = ""
            else:
                noexcept = "noexcept"

            decl += f"""
                {method.comment}
                {return_type} {method.name}({parameters}) {noexcept};
            """

            impl += f"""
                inline {return_type} omni::core::Generated<{interface.abi_name}>::{method.name}({parameters}) {noexcept}
                {{
                    {pre_abi_call}{abi_call}{post_abi_call}
                }}
            """

        # on the second pass create more complex wrappers
        for method in interface.methods:
            if method.attributes.consumer:
                output = self._convert_add_consumer(method)
                decl += output[0]
                impl += output[1]

        decl += "};\n"

        return decl, impl

    def _convert_return(self, method):
        if method.returns_interface_pointer and not method.returns_interface_pointer_without_acquire:
            return f"omni::core::ObjectPtr<{method.return_type_pointee_name}>"
        elif method.returns_kit_interface_pointer:
            return f"carb::ObjectPtr<{method.return_type_pointee_name}>"
        elif method.throws_result:
            return "void"
        elif method.can_return_reference:
            return f"{method.return_type_pointee_name}&"
        else:
            return method.return_type_name

    def _convert_parameter(self, method, param):
        parameters_text = ""
        pre_call_text = ""
        call_text = ""
        post_call_text = ""
        throws = False
        return_type_text = ""
        return_text = ""
        if param.is_returned:
            if method.throws_result or method.returns_void:
                if param.is_interface_pointer:
                    self._reporter.error(
                        param.cursor,
                        f"'{param.returned_indirection}return' OMNI_ATTR cannot be used on interface pointers (only interface pointers to pointers)",
                    )
                elif param.is_pointer_to_interface_pointer and not param.no_acquire:
                    if param.returned_indirection == "*":
                        var_type = f"omni::core::ObjectPtr<{param.pointee_pointee_name}>"
                        pre_call_text = f"{var_type} {param.name};"
                        call_text = f"{param.name}.put()"
                        return_type_text = var_type
                        return_text = f"return {param.name};"
                    else:
                        self._reporter.error(
                            param.cursor,
                            f"'{param.returned_indirection}return' OMNI_ATTR currently only supports using a single '*' to return an interface pointer",
                        )
                else:
                    var_type = f"{param.pointee_name}{param.returned_indirection[:-1]}"
                    pre_call_text = f"{var_type} {param.name};"
                    call_text = f"&{param.name}"
                    return_type_text = var_type
                    return_text = f"return {param.name};"
            else:
                self._reporter.error(param.cursor, "'return' OMNI_ATTR cannot be used on a method that already returns")
        elif param.is_interface_pointer or param.is_kit_interface_pointer:
            parameters_text = f"omni::core::ObjectParam<{param.pointee_name}> {param.name}"
            call_text = f"{param.name}.get()"
        elif param.is_va_list:
            parameters_text = "..."
            prev_param = method.get_previous_parameter(param)
            pre_call_text = f"va_list arg_list_;\nva_start(arg_list_, {prev_param.name});\n"
            call_text = "arg_list_"
            post_call_text = f"va_end(arg_list_)\n;"
        elif param.is_struct:
            # abi accepts a struct by value. pass by ref here to avoid a copy.
            parameters_text = f"const {param.type_name}& {param.name}"
            call_text = param.name
        elif param.can_be_a_reference:
            parameters_text = f"{param.pointee_name}& {param.name}"
            call_text = f"&{param.name}"
        else:
            parameters_text = f"{param.type_name} {param.name}"
            call_text = param.name

        if param.throw_if_null and not param.can_be_a_reference and not param.is_returned:
            pre_call_text = f"{pre_call_text}OMNI_THROW_IF_ARG_NULL({param.name});\n"
            throws = True

        return parameters_text, pre_call_text, call_text, post_call_text, throws, return_type_text, return_text

    def _convert_add_consumer(self, add_method):
        decl = ""
        impl = ""
        add_consumer = AddConsumer(self._hierarchy, add_method, self.reporter)

        callback_method = add_consumer.callback_method

        callback_parameters_text, callback_parameter_names_text = callback_method.parameters_as_abi_text

        std_function_type_name = f"std::function<{callback_method.return_type_name}({callback_parameters_text})>"

        return_statement = ""
        if not callback_method.returns_void:
            return_statement = "return"

        consumer_class_text = f"""
            class Consumer : public omni::core::Implements<{add_consumer.consumer.name}>
            {{
            public:
                virtual {callback_method.return_type_name} {callback_method.abi_name}({callback_parameters_text}) noexcept override
                {{
                    {return_statement} m_function({callback_parameter_names_text});
                }}

                Consumer({std_function_type_name} cb) : m_function(std::move(cb)) {{ }}

            private:
                {std_function_type_name} m_function;
            }};
            """

        decl = f"""
            {add_method.comment}
            omni::core::ObjectPtr<{add_consumer.consumer.name}> {add_method.name}({std_function_type_name} fun) noexcept;
            """

        impl = f"""
            inline omni::core::ObjectPtr<{add_consumer.consumer.name}> omni::core::Generated<{add_method.interface.abi_name}>::{add_method.name}({std_function_type_name} fun) noexcept
            {{
                {consumer_class_text}
                auto consumer{{ omni::core::steal(new Consumer{{ std::move(fun) }}) }};
                {add_method.abi_name}(consumer.get());
                return consumer;
            }}
            """

        return decl, impl

    def _convert_struct(self, struct):
        if not struct.is_opaque:
            return f'static_assert(std::is_standard_layout<{struct.name}>::value, "{struct.name} must be standard layout to be used in ONI ABI");\n'
        else:
            return ""


class PyGenerator(CodeGenerator):
    """Code generator for generating C++ Python bindings."""

    def __init__(
        self,
        matches,
        hierarchy,
        out_filename,
        *,
        skip_write_if_same,
        fail_on_write,
        reporter: DiagnosticReporter,
        format_module=None,
        repo_root=None,
    ):
        super().__init__(
            matches,
            hierarchy,
            out_filename,
            skip_write_if_same=skip_write_if_same,
            fail_on_write=fail_on_write,
            reporter=reporter,
            format_module=format_module,
            repo_root=repo_root,
        )

        self._opaque_structs = []
        self._written_opaque_structs = {}

        self._write(
            f"""\
// Copyright (c) {self._copyright_year}, NVIDIA CORPORATION. All rights reserved.
//
// NVIDIA CORPORATION and its licensors retain all intellectual property
// and proprietary rights in and to this software, related documentation
// and any modifications thereto. Any use, reproduction, disclosure or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA CORPORATION is strictly prohibited.
//
// --------- Warning: This is a build system generated file. ----------
//
#pragma once

#include <omni/core/ITypeFactory.h>
#include <omni/python/PyBind.h>
#include <omni/python/PyString.h>
#include <omni/python/PyVec.h>
#include <sstream>
"""
        )

        out = ""
        for group in matches.constant_groups:
            if not group.attributes.no_py:
                out += self._convert_flag(group, False)

        for flag in matches.flags:
            if not flag.attributes.no_py:
                out += self._convert_flag(flag)

        for enum in matches.enums:
            if not enum.attributes.no_py:
                out += self._convert_enum(enum)

        for struct in matches.structs:
            if not struct.attributes.no_py:
                out += self._convert_struct(struct)

        for interface in matches.interfaces:
            if not interface.attributes.no_py:
                out += self._convert_interface(interface)

        for opaque in self._opaque_structs:
            self._write(self._convert_opaque_struct(opaque))

        self._write(out)
        self._commit()

    def _convert_flag(self, flag, is_arithmetic=True):
        if len(flag.values) == 0:
            return ""

        enum_type_name = f"{flag.short_name}_enum"

        enum_definition = ""
        enum_values = ""
        for value in flag.values:
            enum_definition += f"{value.short_name}_value = {value.name},\n"
            enum_values += f'e.value("{to_snake_case(value.no_prefix_short_name).upper()}", {value.short_name}_value{self._get_comment(value)});\n'

        extra = ""
        if is_arithmetic:
            extra = ", py::arithmetic()"

        return f"""
            auto bind{flag.short_name}(py::module& m)
            {{
                enum {enum_type_name}
                {{
                    {enum_definition}
                }};

                py::enum_<{enum_type_name}> e(m, "{flag.short_name}"{extra}{self._get_comment(flag)});
                {enum_values}
                return e;
            }}
        """

    def _convert_enum(self, enum):
        enum_values = ""
        for value in enum.values:
            enum_values += f'e.value("{to_snake_case(value.no_prefix_short_name).upper()}", {value.name}{self._get_comment(value)});\n'

        return f"""
            auto bind{enum.short_name}(py::module& m)
            {{
                py::enum_<{enum.name}> e(m, "{enum.short_name}"{self._get_comment(enum)});
                {enum_values}
                return e;
            }}
        """

    def _convert_struct(self, struct):
        struct_fields = ""
        init_params = ""
        init_py_args = ""
        vec_field_count = 0
        init_text = ""
        vec_init_text = ""
        str_format = ""
        comma = ""
        for field in struct.fields:
            fixed_length_string = field.is_fixed_length_string()

            if field.attributes.no_py:
                continue
            if field.attributes.init_arg:
                if fixed_length_string:
                    init_params += f"{comma}const char* {field.short_name}"
                    init_text += f"carb::extras::copyStringSafe(tmp.{field.short_name}, CARB_COUNTOF(tmp.{field.short_name}), {field.short_name});\n"
                else:
                    init_params += f"{comma}{field.type_name} {field.short_name}"
                    init_text += f"tmp.{field.short_name} = {field.short_name};\n"

                str_format += f' << "{comma}" << self.{field.short_name}'
                comma = ", "
                init_py_args += f', py::arg("{to_snake_case(field.short_name)}")'
                vec_init_text += f"tmp.{field.short_name} = s[{vec_field_count}].cast<{field.type_name}>();\n"
                vec_field_count += 1

            if fixed_length_string:
                struct_fields += f"""s.def_property("{to_snake_case(field.short_name)}",
                                       [](const {struct.name}* self) -> const char* {{ return self->{field.short_name}; }},  // getter
                                       []({struct.name}* self, const char* value) -> void {{ // setter
                                           carb::extras::copyStringSafe(self->{field.short_name}, CARB_COUNTOF(self->{field.short_name}), value);
                                       }}{self._get_comment(field)});\n"""
            else:
                struct_fields += (
                    f's.def_readwrite("{to_snake_case(field.short_name)}", &{field.name}{self._get_comment(field)});\n'
                )

        init = ""
        if len(init_py_args) > 0:
            init = f"""
                s.def(py::init([]({init_params}) {{
                    {struct.name} tmp;
                    {init_text}
                    return tmp;
                }}){init_py_args});
                """

        if struct.attributes.vec and (vec_field_count > 0):
            field_type = struct.fields[0].element_type_name
            num_fields = vec_field_count
            decl = f"""
                auto s = omni::python::details::bindVec<{struct.name}, {field_type}, {num_fields}>(m, "{struct.short_name}"{self._get_comment(struct)});
                s.def(py::init([](py::sequence s) -> {struct.name} {{
                    {struct.name} tmp;
                    {vec_init_text}
                    return tmp;
                }}));
                s.def("__str__", [](const {struct.name}& self) {{
                    std::ostringstream out;
                    out << '(' {str_format} << ')';
                    return out.str();
                }});
                """
        else:
            decl = f'py::class_<{struct.name}> s(m, "{struct.short_name}");'

        return f"""
            auto bind{struct.short_name}(py::module& m)
            {{
                {decl}
                {init}
                {struct_fields}
                return s;
            }}
        """

    def _get_comment(self, obj):
        comment = obj.comment

        # TODO: this logic isn't complete

        # remove /*, */, leading *, trailing space.
        # https://regex101.com/ is your friend
        comment = re.sub(r"^\s*(/\*\*?|\*/?)?(?P<text>.*?)(\*/)?\s*$", r"\g<text>", comment, flags=re.MULTILINE)

        # remove //, //!, //!<
        comment = re.sub(r"^\s*//!?<? ?(.*)$", r"\1", comment, flags=re.MULTILINE)

        # remove empty lines at beginning
        start = 0
        lines = comment.splitlines()
        for i in range(len(lines)):
            if not re.match(r"^\s*$", lines[i]):
                start = i
                break

        # remove empty lines at end
        end = start
        for i in reversed(range(start, len(lines))):
            if not re.match(r"^\s*$", lines[i]):
                end = i
                break
        lines = lines[start : (end + 1)]

        # find the common amount of leading spaces on each line
        min_leading_spaces = 100000000000
        for i in range(len(lines)):
            if not re.match(r"^\s*$", lines[i]):  # if not "empty"
                leading = len(lines[i]) - len(lines[i].lstrip())
                min_leading_spaces = min(leading, min_leading_spaces)

        # remove leading spaces
        if min_leading_spaces > 0:
            for i in range(len(lines)):
                lines[i] = lines[i][min_leading_spaces:]

        comment = "\n".join(lines)

        if len(comment) > 0:
            return f', R"OMNI_BIND_RAW_({comment})OMNI_BIND_RAW_"'
        else:
            return ""

    def _convert_interface(self, interface):
        output = f"""
            auto bind{interface.short_name}(py::module& m)
            {{
                // hack around pybind11 issues with C++17
                //   - https://github.com/pybind/pybind11/issues/2234
                //   - https://github.com/pybind/pybind11/issues/2666
                //   - https://github.com/pybind/pybind11/issues/2856
                py::class_<omni::core::Generated<{interface.abi_name}>, omni::core::ObjectPtr<omni::core::Generated<{interface.abi_name}>>, {interface.baseName}> clsParent(m, "_{interface.short_name}");
                py::class_<{interface.name}, omni::core::Generated<{interface.abi_name}>, omni::core::ObjectPtr<{interface.name}>, {interface.baseName}> cls(m, "{interface.short_name}"{self._get_comment(interface)});
                cls.def(py::init([](const omni::core::ObjectPtr<omni::core::IObject>& obj) {{
                    auto tmp = omni::core::cast<{interface.name}>(obj.get());
                    if (!tmp)
                    {{
                        throw std::runtime_error("invalid type conversion");
                    }}
                    return tmp;
                }}));
                cls.def(py::init([]() {{
                    auto tmp = omni::core::createType<{interface.name}>();
                    if (!tmp)
                    {{
                        throw std::runtime_error("unable to create {interface.name} instantiation");
                    }}
                    return tmp;
                }}));
            """

        for name, prop in interface.properties.items():
            output += self._convert_property(interface, name, prop)

        for method in interface.methods:
            if method.attributes.no_py:
                continue

            is_py_property = method.is_property and (not method.attributes.py_not_prop)
            bind_raw_get_set = method.attributes.py_get or method.attributes.py_set
            if is_py_property and (not bind_raw_get_set):
                continue

            if method.attributes.consumer:
                output += self._convert_add_consumer(method)
            else:
                name, code, arg_names, return_policy = self._convert_method(interface, method)
                output += f'cls.def("{name}", {code}{self._get_comment(method)}{arg_names}{return_policy});\n'

        output += f"return omni::python::PyBind<{interface.name}>::bind(cls);\n}}\n"

        return output

    def _convert_add_consumer(self, add_method):
        add_consumer = AddConsumer(self._hierarchy, add_method, self.reporter)

        callback_method = add_consumer.callback_method

        parameters_text = ""  # signature of the std::function pybind will wrap (should contain pybind friend types)
        pre_call_text = ""  # converts c++ owned memory to python
        call_return_text = ""  # return statement from callback (if needed)
        call_text = ""  # parameters passed when calling the std::function
        post_call_list = []  # converts the result of the std::function back to c++
        return_type_text = "void"

        separator = ""
        for i in range(len(callback_method.parameters)):
            param = callback_method.parameters[i]

            sig = ""
            pre = ""
            call = ""
            post = ""
            ret = ""

            if param.is_interface_pointer:
                sig = f"const omni::core::ObjectPtr<{param.pointee_name}>&"
                call = f"omni::core::borrow({param.name})"
            elif param.is_kit_interface_pointer:
                sig = f"const carb::ObjectPtr<{param.pointee_name}>&"
                call = f"omni::core::borrow({param.name})"
            elif param.is_pointer:
                sig, pre, call, post, ret = self._convert_add_consumer_pointer_parameter(param)
            elif not param.attributes.count_of:
                sig = param.type_name
                call = param.name

            if len(sig) > 0:
                parameters_text += f"{separator}{sig}\n"
            if len(pre) > 0:
                pre_call_text += f"{pre}\n"
            if len(call) > 0:
                call_text += f"{separator}{call}\n"
            if len(post) > 0:
                post_call_list.append((post, ret))

            separator = ", "

        if not callback_method.returns_void:
            if callback_method.returns_pointer:
                # TODO: more work needed here
                self.reporter.error(
                    callback_method.cursor, "returning a pointer from a consumer callback is not yet supported"
                )
            else:
                # returns something by value
                call_return_text = "auto return_value = "
                post_call_list.append(
                    ("return omni::python::PyCopy<{param.return_type_name}>::fromPython(__PY_RETURN__);", "py::object")
                )

        post_call_text = ""
        if len(post_call_list) == 1:
            call_return_text = "auto return_value = "
            post_call, return_type_text = post_call_list[0]
            post_call_text = post_call.replace("__PY_RETURN__", "return_value")
        elif len(post_call_list) > 1:
            call_return_text = "auto return_value = "
            return_type_text = "py::sequence"
            i = 0
            for item in post_call_list:
                post_call = item[0]
                post_call_text = post_call.replace("__PY_RETURN__", f"return_value[{i}]")
                i += 1

        callback_parameters_text, callback_parameter_names_text = callback_method.parameters_as_abi_text

        lambda_text = f"""
            []({add_method.interface.name}* self, std::function<{return_type_text}({parameters_text})> fn)
            {{
                return self->{add_method.name}(
                    [=]({callback_parameters_text}) noexcept
                    {{
                        try
                        {{
                            {pre_call_text}
                            {call_return_text}fn({call_text});
                            {post_call_text}
                        }}
                        catch (std::exception& e)
                        {{
                            OMNI_LOG_ERROR("%s", e.what());
                        }}
                    }});
            }}
            """

        return f"""
            cls.def("{to_snake_case(add_method.name)}",
                {lambda_text}
                {self._get_comment(add_method)}
                );
            """

    def _convert_add_consumer_pointer_parameter(self, param):
        parameters_text = ""  # signature of the std::function pybind will wrap (should contain pybind friendly types)
        pre_call_text = ""  # converts c++ owned memory to python
        call_text = ""  # parameters passed when calling the std::function
        post_call_text = ""  # converts the result of the std::function back to c++
        return_type_text = ""

        if param.is_array:
            if (not param.attributes.input) and param.attributes.output:
                # an output array of pointers. what do we do here?  we don't how big of an
                # array to pass to c (having the caller decided is not pythonic).
                self.reporter.error(param.cursor, "unsupported 'out' array in consumer callback parameters")

            if param.is_pointer_to_pointer:
                # array of pointers
                if not param.attributes.pointee.c_str:
                    self.reporter.error(
                        param.cursor, "unsupported 'in' array of pointers in consumer callback parameters"
                    )

            parameters_text += f"py::sequence"
            pre_call_text += f"omni::python::ArrayToPython<{param.type_name}> {param.name}_py({param.name}, {param.attributes.count});"
            call_text += f"{param.name}_py.getPyObject()"

            if param.attributes.output:
                post_call_text += f"omni::python::throwIfNone(__PY_RETURN__);\n"
                post_call_text += f"omni::python::PyArrayCopy<{param.type_name}>::fromPython({param.name}, {param.attributes.count}, __PY_RETURN__);"
                return_type_text = "py::sequence"
        else:
            if param.attributes.c_str:
                parameters_text += f"{param.type_name} {param.name}"
                call_text += param.name

            # pointer (e.g. KeyboardEvent*) to a single item
            if param.attributes.input:
                parameters_text += f"{param.type_name} {param.name}"
                pre_call_text += f"omni::python::ValueToPython<{param.type_name}> {param.name}_py_copy({param.name});"
                call_text += f"{param.name}_py_copy.getData()"

            if param.attributes.output:
                post_call_text += f"omni::python::throwIfNone(__PY_RETURN__);\n"
                post_call_text += f"omni::python::PyCopy<{param.type_name}>::fromPython({param.name}, __PY_RETURN__);"
                return_type_text = "py::object"

        return parameters_text, pre_call_text, call_text, post_call_text, return_type_text

    def _convert_method(self, interface, method):
        needs_lambda = False

        parameters_text = ""  # signature of the lambda wrapper
        argnames = []  # names of py::arg specifier
        pre_call_text = ""  # converts python owned memory to c
        call_text = ""  # parameters passed when calling the c abi method
        post_call_text = ""  # converts the result of the abi call to python
        return_list = []  # list of py::object's to return to python
        return_policy = ""

        if method.attributes.ref:
            self.reporter.error(
                method.cursor,
                "'ref' attribute not yet supported in python bindings. use 'no_py' on method to avoid this error.",
            )
        if method.returns_interface_pointer_without_acquire:
            self.reporter.error(
                method.cursor,
                "'no_acquire' attribute and 'WithoutAcquire' postfix are not yet supported in python bindings. use 'no_py' on method to avoid this error.",
            )
        if method.attributes.throw_result:
            self.reporter.error(
                method.cursor,
                "'throw_result' attribute not yet supported in python bindings. use 'no_py' on method to avoid this error.",
            )

        call_return_text, post_call_text, ret, return_policy = self._convert_method_return(method)
        if len(ret) > 0:
            return_list.append(ret)

        separator = ""
        for param in method.parameters:
            sig = ""
            pre = ""
            call = ""
            post = ""
            ret = ""

            if param.attributes.ref:
                self.reporter.error(
                    param.cursor,
                    "'ref' attribute not yet supported in python bindings. use 'no_py' on method to avoid this error.",
                )
            if param.attributes.no_acquire:
                self.reporter.error(
                    param.cursor,
                    "'no_acquire' attribute not yet supported in python bindings. use 'no_py' on method to avoid this error.",
                )
            if param.attributes.returned:
                self.reporter.error(
                    param.cursor,
                    "'return' attribute not yet supported in python bindings. use 'no_py' on method to avoid this error.",
                )

            if param.is_interface_pointer or param.is_kit_interface_pointer:
                sig = f"{param.type_name} {param.name}"
                call = param.name
                needs_lambda = True
            elif param.is_va_list:
                self.reporter.error(method.cursor, "va_list is not currently supported")
            elif param.is_pointer:
                sig, pre, call, post, ret = self._convert_method_pointer_parameter(param)

                # TODO: we don't need the lambda if the pointer was 'in'
                needs_lambda = True
            elif param.attributes.count_of:
                call = f"{param.attributes.count_of.name}.getCount()"
                needs_lambda = True
            elif param.is_struct:
                sig = f"{param.type_name}* {param.name}"
                call = f"*{param.name}"
                needs_lambda = True
            else:
                sig = f"{param.type_name} {param.name}"
                call = param.name

            if len(sig) > 0:
                parameters_text += f"{separator}{sig}\n"
                argnames.append(param.attributes.py_name or to_snake_case(param.name))
            if len(pre) > 0:
                pre_call_text += f"{pre}\n"
            if len(call) > 0:
                call_text += f"{separator}{call}\n"
            if len(post) > 0:
                post_call_text += f"{post}\n"
            if len(ret) > 0:
                return_list.append(ret)

            separator = ", "

        return_text = ""
        if len(return_list) > 1:
            pre_call_text = f"py::tuple returnTuple({len(return_list)});\n{pre_call_text}"
            for i in range(len(return_list)):
                return_text += f"returnTuple[{i}] = {return_list[i]};\n"
            return_text += "return returnTuple;\n"
            needs_lambda = True
        elif len(return_list) == 1:
            return_text += f"return {return_list[0]};"

        if (len(parameters_text) > 0) and (parameters_text[0] != ","):
            parameters_text = f", {parameters_text}"

        method_name = method.attributes.py_name
        if not method_name:
            method_name = to_snake_case(method.name)

        if len(argnames) > 0:
            argnames_text = ", " + str.join(", ", (f'py::arg("{x}")' for x in argnames))
        else:
            argnames_text = ""

        if needs_lambda:
            func = f"""
                []({interface.name}* self{parameters_text})
                {{
                    {pre_call_text}
                    {call_return_text} self->{method.name}({call_text});
                    {post_call_text}
                    {return_text}
                }}
                """
            return method_name, func, argnames_text, return_policy
        else:
            return method_name, f"&{interface.name}::{method.name}", argnames_text, return_policy

    def _convert_method_pointer_parameter(self, param):
        parameters_text = ""  # signature of the lambda wrapper
        pre_call_text = ""  # converts python owned memory to c
        call_text = ""  # parameters passed when calling the c abi method
        post_call_text = ""  # converts the result of the abi call to python
        return_text = ""  # code to run to return a py::object to python

        if param.is_array:
            if (not param.attributes.input) and param.attributes.output:
                # an output array of pointers. what do we do here?  we don't know how big of an
                # array to pass to c (having the caller decided is not pythonic).
                self.reporter.error(
                    param.cursor,
                    'unsupported "out" array in method parameters. add OMNI_ATTR("no_py") to method and manually define Python bindings.',
                )

            if param.is_pointer_to_pointer:
                # array of pointers
                # XXX if not (param.attributes.pointee.c_str or is_interface(param.pointee_type)):
                self.reporter.error(
                    param.cursor,
                    'unsupported "in" array in method parameters. add OMNI_ATTR("no_py") to method and manually define Python bindings.',
                )

            parameters_text += f"py::sequence {param.name}_in"
            pre_call_text += f"omni::python::ArrayFromPython<{param.type_name}> {param.name}({param.name}_in);"
            call_text += f"{param.name}.getData()"

            if param.attributes.output:
                return_text += f"{param.name}.createPyObject()"
        else:
            # pointer to something concrete (e.g KeyboardEvent*)
            if param.attributes.output:
                if param.attributes.input:
                    parameters_text += f"{param.type_name} {param.name}"
                    pre_call_text += f"omni::python::PointerFromPython<{param.type_name}> {param.name}_c({param.name});"
                else:
                    pre_call_text += f"omni::python::PointerFromPython<{param.type_name}> {param.name}_c;"
                call_text += f"{param.name}_c.getData()"
                return_text += f"{param.name}_c.createPyObject()"
            else:
                parameters_text += f"{param.type_name} {param.name}"
                call_text += param.name

        if param.is_opaque_struct_pointer:
            self._opaque_structs.append(param.opaque_struct_pointer_info)

        return parameters_text, pre_call_text, call_text, post_call_text, return_text

    def _convert_method_return(self, method):
        call_return_text = ""
        post_call_text = ""
        return_text = ""
        return_policy = ""

        # TODO: more work needed here
        if not method.returns_void:
            call_return_text = "auto return_value = "
            return_text = "return_value"

        if method.returns_opaque_struct_pointer:
            return_policy = ", py::return_value_policy::reference"
            self._opaque_structs.append(method.return_type_opaque_struct_pointer_info)

        return call_return_text, post_call_text, return_text, return_policy

    def _convert_property(self, interface, name, prop):
        set_method_text = ""
        get_method_text = ""
        get_return_policy = ""
        if prop["set"] and (not prop["set"].attributes.no_py) and (not prop["set"].attributes.py_not_prop):
            _, set_method_text, _, _ = self._convert_method(interface, prop["set"])
        if prop["get"] and (not prop["get"].attributes.no_py) and (not prop["get"].attributes.py_not_prop):
            _, get_method_text, _, get_return_policy = self._convert_method(interface, prop["get"])

        snake_case_name = to_snake_case(name)
        if (len(set_method_text) > 0) and (len(get_method_text) > 0):
            return f'cls.def_property("{snake_case_name}", {get_method_text}{get_return_policy}, {set_method_text});\n'
        elif len(get_method_text) > 0:
            return f'cls.def_property_readonly("{snake_case_name}", {get_method_text}{get_return_policy});\n'
        elif len(set_method_text) > 0:
            return f'cls.def_property("{snake_case_name}", nullptr, {set_method_text});\n'

        return ""

    def _convert_opaque_struct(self, opaque):
        full_name = ""
        for ns in opaque["namespace"]:
            full_name = f"{full_name}::{ns}"
        full_name = f"{full_name}::{opaque['name']}"

        if full_name in self._written_opaque_structs:
            return ""

        self._written_opaque_structs[full_name] = True

        out = ""
        num_closing_curly_needed = 0
        for ns in opaque["namespace"]:
            out = f"{out}namespace {ns} {{\n"
            num_closing_curly_needed += 1

        out = f"{out}{opaque['type']} {opaque['name']} {{}};\n"
        for i in range(num_closing_curly_needed):
            out = f"{out}}}\n"

        return out


class AddConsumer(object):
    """
    Given an add/registration Method, validates the method follows add/register consumer guidelines, and finds the
    consumer's callback method in the AST (see callback_method).
    """

    def __init__(self, hierarchy, add_method, reporter: DiagnosticReporter):
        assert isinstance(reporter, DiagnosticReporter)
        self._reporter = reporter

        assert add_method.attributes.consumer
        callback_name = add_method.attributes.consumer
        if not callback_name.endswith("_abi"):
            self._reporter.error(add_method.cursor, "given consumer callback, {}, must end with _abi", callback_name)
        if 1 != len(add_method.parameters):
            self._reporter.error(add_method.cursor, "consumer methods must accept a single parameter")

        # the first (and only) parameter is the consumer to add
        self._consumer = add_method.parameters[0].as_interface

        self._callback_method = self._find_callback(hierarchy, callback_name)
        if not self._callback_method:
            self._reporter.error(
                add_method.cursor, "cannot find consumer callback: {}::{}", self.consumer.name, callback_name
            )

    @property
    def consumer(self):
        """Returns an Interface() pointing to the interface/consumer type that this method registers/add."""
        return self._consumer

    @property
    def callback_method(self):
        """Returns a Method() pointing to the consumer callback method."""
        return self._callback_method

    def _find_callback(self, hierarchy, callback_name):
        chain = hierarchy.get_hierarchy(self._consumer.cursor.canonical)
        for cls in chain:
            if cls.spelling.endswith("_abi"):
                tmp = model.Interface(cls, hierarchy, self._reporter)
                for method in tmp.methods:
                    if method.abi_name == callback_name:
                        return method
        return None
